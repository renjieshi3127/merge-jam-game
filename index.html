<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merge Jam</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 500px;
            background-color: #eef2f5;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden; 
        }

        .top-spacer {
            height: 10px; 
            background: #fff;
            flex-shrink: 0;
        }

        canvas {
            flex: 1;
            width: 100%;
            height: 100%;
            display: block;
            background: #fff;
        }

        #toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 800;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            white-space: nowrap;
            z-index: 100;
        }

        /* === ÈÄöÁî®ÂºπÁ™óÊ†∑Âºè === */
        #victoryModal, #failModal {
            display: none; /* ÈªòËÆ§ÈöêËóè */
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease-out;
        }

        .victory-content {
            background: #fff;
            padding: 30px 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: scale(0.8);
            animation: popUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            width: 70%;
            max-width: 300px;
        }

        .victory-title {
            font-size: 28px;
            margin: 0 0 10px 0;
            color: #ffb400; 
        }

        .victory-desc {
            font-size: 16px;
            color: #666;
            margin-bottom: 25px;
        }

        .restart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 12px 30px;
            color: white;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            transition: transform 0.1s;
            width: 100%;
        }
        .restart-btn:active {
            transform: scale(0.95);
        }

        @keyframes popUp { to { transform: scale(1); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

<div id="gameContainer">
    <div class="top-spacer"></div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="toast"></div>

    <div id="victoryModal">
        <div class="victory-content">
            <h1 class="victory-title">üéâ LEVEL CLEARED!</h1>
            <p class="victory-desc">Great job cleaning up the jam!</p>
            <button class="restart-btn" onclick="initLevel()">ÂÜçÁé©‰∏ÄÊ¨°</button>
        </div>
    </div>

    <div id="failModal">
        <div class="victory-content">
            <h1 class="victory-title" style="color: #ff4757">üö´ OUT OF SPACE!</h1>
            <p class="victory-desc">ËΩ¶Â∫ìÂ∑≤ÁªèÊª°‰∫ÜÔºåÊó†Ê≥ïÁªßÁª≠„ÄÇ</p>
            <button class="restart-btn" style="background: linear-gradient(135deg, #ff4757 0%, #ff6b81 100%); box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);" onclick="initLevel()">ÈáçÊñ∞ÂºÄÂßã</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const toast = document.getElementById('toast');
    const victoryModal = document.getElementById('victoryModal');
    const failModal = document.getElementById('failModal');

    // --- Ê†∏ÂøÉÂèÇÊï∞ ---
    const GRID_COLS = 7; 
    const GRID_ROWS = 10; 
    const DOCK_CAPACITY = 5;
    
    let CELL_SIZE, OFFSET_X, OFFSET_Y, CANVAS_W, CANVAS_H;
    const TOP_UI_HEIGHT = 140; 

    const COLORS = {
        gridBg: '#dbe4eb',
        gridLine: '#c5d1db',
        dockSlot: '#f0f2f5',
        dockBorder: '#d1d9e6'
    };

    const VEHICLE_TYPES = ['üö≤', 'üèçÔ∏è', 'üõ∫', 'üöó', 'üöê', 'üöå']; 

    // --- Ê∏∏ÊàèÁä∂ÊÄÅ ---
    let dock = []; 
    let vehicles = []; 
    let flyingVehicles = []; // Â≠òÂÇ®È£ûÂá∫ÁöÑÁâπÊïàËΩ¶
    let isAnimating = false; 
    let isLevelCleared = false; 
    let isGameOver = false;

    // --- ÂÖºÂÆπÊÄßÁªòÂõæÂ∑•ÂÖ∑ (Èò≤Ê≠¢ÁôΩÂ±è) ---
    function drawRoundRect(ctx, x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }

    class Vehicle {
        constructor(id, typeIndex, c, r, w, h, direction) {
            this.id = id;
            this.typeIndex = typeIndex;
            this.c = c; 
            this.r = r; 
            this.w = w; 
            this.h = h; 
            this.direction = direction; 
            this.vx = 0;
            this.vy = 0;
            this.isExiting = false;
            
            const hue = (typeIndex * 45 + 10) % 360;
            this.color = `hsl(${hue}, 85%, 70%)`;
            this.stroke = `hsl(${hue}, 80%, 55%)`;
        }

        initVisualPos() {
            this.vx = OFFSET_X + this.c * CELL_SIZE;
            this.vy = OFFSET_Y + this.r * CELL_SIZE;
        }

        get emoji() { return VEHICLE_TYPES[this.typeIndex]; }

        getOccupiedCells() {
            let cells = [];
            for(let i=0; i<this.h; i++) {
                for(let j=0; j<this.w; j++) {
                    cells.push({c: this.c + j, r: this.r + i});
                }
            }
            return cells;
        }

        contains(x, y) {
            const vw = this.w * CELL_SIZE;
            const vh = this.h * CELL_SIZE;
            return x >= this.vx && x < this.vx + vw &&
                   y >= this.vy && y < this.vy + vh;
        }

        update() {
            if (this.isExiting) {
                const speed = 35; 
                if (this.direction === 'up') this.vy -= speed;
                if (this.direction === 'down') this.vy += speed;
                if (this.direction === 'left') this.vx -= speed;
                if (this.direction === 'right') this.vx += speed;
                
                if (this.direction === 'up') {
                    if (this.vy < TOP_UI_HEIGHT) return false; 
                } else {
                    if (this.vx < -200 || this.vx > CANVAS_W + 200 || 
                        this.vy > CANVAS_H + 200) {
                        return false; 
                    }
                }
            }
            return true; 
        }
    }

    class FlyingVehicle {
        constructor(emoji, x, y) {
            this.emoji = emoji;
            this.x = x;
            this.y = y;
            this.vy = -12; 
            this.vx = (Math.random() - 0.5) * 4; 
            this.scale = 1.6;
            this.alpha = 1.0;
            this.rotation = 0;
            this.rotSpeed = (Math.random() - 0.5) * 0.2;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy *= 1.05; 
            this.rotation += this.rotSpeed;
            return this.y > -100;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale, this.scale);
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = '#333';
            ctx.font = '32px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, 0, 0);
            
            ctx.fillStyle = '#ffb400';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText("MAX!", 0, -30);
            ctx.restore();
        }
    }

    function initLevel() {
        victoryModal.style.display = 'none';
        failModal.style.display = 'none';
        
        isLevelCleared = false;
        isGameOver = false;
        dock = [];
        vehicles = [];
        flyingVehicles = [];
        
        resize();
        
        let idCounter = 1;
        const addV = (type, c, r, w, h, dir) => {
            let v = new Vehicle(idCounter++, type, c, r, w, h, dir);
            vehicles.push(v);
        };

        // --- ÂÖ≥Âç°ÈÖçÁΩÆ ---
        addV(0, 1, 0, 1, 2, 'up'); 
        addV(0, 5, 0, 1, 2, 'up'); 
        addV(2, 1, 8, 1, 2, 'down'); 
        addV(1, 5, 8, 1, 2, 'down'); 
        addV(2, 2, 0, 3, 1, 'right'); 
        addV(0, 0, 2, 1, 2, 'left'); 
        addV(0, 6, 2, 1, 2, 'right'); 
        addV(1, 2, 5, 1, 2, 'down');   
        addV(1, 3, 5, 1, 2, 'down');  
        addV(1, 4, 5, 1, 2, 'down');    
        addV(1, 0, 4, 2, 1, 'up'); 
        addV(2, 5, 4, 2, 1, 'up'); 
        addV(3, 2, 2, 2, 2, 'down'); 
        addV(3, 4, 2, 1, 2, 'down'); 
        addV(4, 2, 7, 3, 1, 'right'); 
        addV(4, 3, 1, 2, 1, 'right'); 
        addV(3, 0, 8, 1, 2, 'up'); 
        addV(1, 6, 8, 1, 2, 'right'); 
        addV(4, 2, 8, 2, 1, 'right'); 
        addV(4, 5, 7, 2, 1, 'up'); 
        addV(2, 0, 7, 2, 1, 'left'); 
        addV(1, 0, 5, 2, 1, 'left');   
        addV(1, 0, 6, 2, 1, 'left');   
        addV(1, 5, 6, 2, 1, 'right'); 
        addV(2, 5, 5, 2, 1, 'right');  
        addV(4, 2, 4, 3, 1, 'right'); 
        addV(2, 4, 8, 1, 2, 'down'); 
        addV(4, 2, 9, 2, 1, 'right'); 
        addV(1, 0, 0, 1, 2, 'right'); 
        addV(3, 1, 2, 1, 2, 'right'); 
        addV(3, 6, 0, 1, 2, 'right'); 
        addV(3, 5, 2, 1, 2, 'right'); 

        vehicles.forEach(v => v.initVisualPos());
        
        if(!isAnimating) {
            isAnimating = true;
            requestAnimationFrame(gameLoop);
        }
    }

    function gameLoop() {
        update();
        draw();
        if (isAnimating) requestAnimationFrame(gameLoop);
    }

    function update() {
        if (isGameOver || isLevelCleared) return; 

        // Êõ¥Êñ∞ËΩ¶ËæÜ
        for (let i = vehicles.length - 1; i >= 0; i--) {
            const v = vehicles[i];
            const alive = v.update();
            if (!alive) {
                vehicles.splice(i, 1);
                handleEnterDock(v.typeIndex); 
            }
        }

        // Êõ¥Êñ∞ÁâπÊïàËΩ¶ËæÜ
        for (let i = flyingVehicles.length - 1; i >= 0; i--) {
            if (!flyingVehicles[i].update()) {
                flyingVehicles.splice(i, 1);
            }
        }
        
        // Êõ¥Êñ∞DockÂºπË∑≥
        dock.forEach(slot => {
            if (slot.scale > 1.0) {
                slot.scale += (1.0 - slot.scale) * 0.2; 
            }
        });

        // ËÉúÂà©Ê£ÄÊµã
        if (vehicles.length === 0 && dock.length === 0 && !isLevelCleared) {
            isLevelCleared = true;
            setTimeout(() => { victoryModal.style.display = 'flex'; }, 500);
        }
    }

    function handleEnterDock(incomingTypeIdx) {
        let currentTypeIdx = incomingTypeIdx;
        let chainCount = 0; 
        
        // Dock UIËÆ°ÁÆóÂèÇÊï∞ (‰∏∫‰∫ÜËé∑ÂèñÁâπÊïàÁîüÊàêÁöÑÂùêÊ†á)
        const dockSlotSize = 55; 
        const dockGap = 12;
        const totalW = DOCK_CAPACITY * dockSlotSize + (DOCK_CAPACITY-1)*dockGap;
        const startX = (CANVAS_W - totalW) / 2;
        const startY = (TOP_UI_HEIGHT - dockSlotSize) / 2;

        while (true) {
            const currentEmoji = VEHICLE_TYPES[currentTypeIdx];
            const matchIdx = dock.findIndex(d => d.type === currentEmoji);

            if (matchIdx !== -1) {
                dock.splice(matchIdx, 1); 
                if (currentTypeIdx < VEHICLE_TYPES.length - 1) {
                    currentTypeIdx++; 
                    chainCount++;
                } else {
                    // === ËææÂà∞ÊúÄÈ´òÁ∫ß ===
                    const slotX = startX + matchIdx * (dockSlotSize + dockGap) + dockSlotSize/2;
                    const slotY = startY + dockSlotSize/2;
                    flyingVehicles.push(new FlyingVehicle(currentEmoji, slotX, slotY));
                    showToast("üéâ ÂÆåÁæéÂá∫Â∫ìÔºÅ");
                    break;
                }
            } else {
                if (dock.length < DOCK_CAPACITY) {
                    const finalEmoji = VEHICLE_TYPES[currentTypeIdx];
                    const popScale = chainCount > 0 ? 1.8 : 1.3; 
                    dock.push({ type: finalEmoji, scale: popScale });
                    if (chainCount > 0) showToast(`‚ö°Ô∏è ËøûÁéØÂêàÊàê x${chainCount}!`);
                } 
                break; 
            }
        }

        // Â§±Ë¥•Ê£ÄÊµã
        if (dock.length >= DOCK_CAPACITY) {
            isGameOver = true;
            shakeCanvas();
            setTimeout(() => { failModal.style.display = 'flex'; }, 800);
        }
    }

    function checkPath(vehicle) {
        let map = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(false));
        vehicles.forEach(v => {
            if (v.id !== vehicle.id && !v.isExiting) { 
                v.getOccupiedCells().forEach(cell => {
                    if(cell.r >=0 && cell.r < GRID_ROWS && cell.c >=0 && cell.c < GRID_COLS) {
                        map[cell.r][cell.c] = true;
                    }
                });
            }
        });

        let dr = 0, dc = 0;
        if (vehicle.direction === 'up') dr = -1;
        if (vehicle.direction === 'down') dr = 1;
        if (vehicle.direction === 'left') dc = -1;
        if (vehicle.direction === 'right') dc = 1;

        let occupiedCells = vehicle.getOccupiedCells();
        let step = 1;
        
        while (true) {
            let allOut = true;
            for (let cell of occupiedCells) {
                let tr = cell.r + dr * step;
                let tc = cell.c + dc * step;
                if (tr >= 0 && tr < GRID_ROWS && tc >= 0 && tc < GRID_COLS) {
                    allOut = false;
                    if (map[tr][tc]) return false; 
                }
            }
            if (allOut) break; 
            if (step > 20) break;
            step++;
        }
        return true;
    }

    function handleInput(x, y) {
        if (isGameOver || isLevelCleared) return; 

        const clickedVehicle = vehicles.find(v => !v.isExiting && v.contains(x, y));
        if (clickedVehicle) {
            if (checkPath(clickedVehicle)) {
                clickedVehicle.isExiting = true;
            } else {
                showToast(`üö´ Â†µ‰Ωè‰∫ÜÔºÅÊñπÂêë: ${getArrowIcon(clickedVehicle.direction)}`);
                shakeCanvas();
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

        // UI BG
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, CANVAS_W, TOP_UI_HEIGHT);
        ctx.strokeStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(0, TOP_UI_HEIGHT); ctx.lineTo(CANVAS_W, TOP_UI_HEIGHT);
        ctx.stroke();

        // Dock
        const dockSlotSize = 55; 
        const dockGap = 12;
        const totalW = DOCK_CAPACITY * dockSlotSize + (DOCK_CAPACITY-1)*dockGap;
        const startX = (CANVAS_W - totalW) / 2;
        const startY = (TOP_UI_HEIGHT - dockSlotSize) / 2;

        for(let i=0; i<DOCK_CAPACITY; i++) {
            const x = startX + i * (dockSlotSize + dockGap);
            const cx = x + dockSlotSize/2;
            const cy = startY + dockSlotSize/2;
            
            ctx.fillStyle = COLORS.dockSlot;
            ctx.strokeStyle = COLORS.dockBorder;
            ctx.lineWidth = 2;
            
            // ‰ΩøÁî®ÂÖºÂÆπÂáΩÊï∞Êõø‰ª£ roundRect
            drawRoundRect(ctx, x, startY, dockSlotSize, dockSlotSize, 12);
            ctx.fill();
            ctx.stroke();

            if (dock[i]) {
                const item = dock[i];
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(item.scale, item.scale);
                ctx.fillStyle = '#333';
                ctx.font = '32px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.type, 0, 4); 
                ctx.restore();
            }
        }

        flyingVehicles.forEach(fv => fv.draw(ctx));

        // Grid (Â∑≤ÁßªÈô§)
        /* ËøôÈáåÂéüÊú¨ÊòØÁªòÂà∂ÁΩëÊ†ºÁöÑ‰ª£Á†Å
        Áé∞Âú®Â∑≤ÁªèÂà†Èô§ÔºåËÉåÊôØÊòØÁ∫ØÁôΩÁöÑ
        */

        // Vehicles
        vehicles.forEach(v => {
            const w = v.w * CELL_SIZE;
            const h = v.h * CELL_SIZE;
            const pad = 4;

            ctx.fillStyle = v.color;
            ctx.strokeStyle = v.stroke;
            ctx.lineWidth = 2;
            
            drawRoundRect(ctx, v.vx + pad, v.vy + pad, w - pad*2, h - pad*2, 10);
            ctx.fill();
            ctx.stroke();

            const cx = v.vx + w/2;
            const cy = v.vy + h/2;

            ctx.save();
            ctx.translate(cx, cy);
            
            if (v.direction === 'right') ctx.scale(-1, 1);
            if (v.direction === 'up') ctx.rotate(Math.PI / 2);
            if (v.direction === 'down') ctx.rotate(-Math.PI / 2);

            ctx.fillStyle = '#fff';
            ctx.font = `${Math.min(w,h)*0.55}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(v.emoji, 0, 4);
            ctx.restore();

            ctx.save();
            ctx.translate(cx, cy);
            let arrowAngle = 0;
            if (v.direction === 'up') arrowAngle = -Math.PI/2;
            if (v.direction === 'down') arrowAngle = Math.PI/2;
            if (v.direction === 'left') arrowAngle = Math.PI;
            ctx.rotate(arrowAngle);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚ûú', 0, 0); 
            ctx.restore();
        });
        
        // UI Mask (ÈÅÆÊå°)
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, CANVAS_W, TOP_UI_HEIGHT); 
        ctx.strokeStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(0, TOP_UI_HEIGHT); ctx.lineTo(CANVAS_W, TOP_UI_HEIGHT);
        ctx.stroke();

        // Redraw Dock Items (‰∏∫‰∫ÜÊòæÁ§∫Âú®Mask‰πã‰∏ä)
        for(let i=0; i<DOCK_CAPACITY; i++) {
            const x = startX + i * (dockSlotSize + dockGap);
            const cx = x + dockSlotSize/2;
            const cy = startY + dockSlotSize/2;
            
            ctx.fillStyle = COLORS.dockSlot;
            ctx.strokeStyle = COLORS.dockBorder;
            ctx.lineWidth = 2;
            
            drawRoundRect(ctx, x, startY, dockSlotSize, dockSlotSize, 12);
            ctx.fill();
            ctx.stroke();

            if (dock[i]) {
                const item = dock[i];
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(item.scale, item.scale);
                ctx.fillStyle = '#333';
                ctx.font = '32px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.type, 0, 4); 
                ctx.restore();
            }
        }
        
        flyingVehicles.forEach(fv => fv.draw(ctx));
    }

    function resize() {
        const container = document.getElementById('gameContainer');
        CANVAS_W = container.clientWidth;
        CANVAS_H = container.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = CANVAS_W * dpr;
        canvas.height = CANVAS_H * dpr;
        ctx.scale(dpr, dpr);

        const availableH = CANVAS_H - TOP_UI_HEIGHT - 30;
        const availableW = CANVAS_W - 20;

        const sizeByW = Math.floor(availableW / GRID_COLS);
        const sizeByH = Math.floor(availableH / GRID_ROWS);
        CELL_SIZE = Math.min(sizeByW, sizeByH);

        OFFSET_X = 10 + (availableW - (CELL_SIZE * GRID_COLS)) / 2;
        OFFSET_Y = TOP_UI_HEIGHT + 10 + (availableH - (CELL_SIZE * GRID_ROWS)) / 2;
        
        if (vehicles) vehicles.forEach(v => v.initVisualPos());
    }
    
    window.addEventListener('resize', () => { resize(); draw(); });
    
    ['mousedown', 'touchstart'].forEach(evt => 
        canvas.addEventListener(evt, e => {
            if (evt === 'touchstart') e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clientX = evt === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = evt === 'touchstart' ? e.touches[0].clientY : e.clientY;
            handleInput(clientX - rect.left, clientY - rect.top);
        }, { passive: false })
    );

    function getArrowIcon(dir) {
        const icons = {up:'‚¨ÜÔ∏è', down:'‚¨áÔ∏è', left:'‚¨ÖÔ∏è', right:'‚û°Ô∏è'};
        return icons[dir] || '';
    }

    function showToast(msg) {
        toast.textContent = msg;
        toast.style.opacity = '1';
        clearTimeout(toast.timer);
        toast.timer = setTimeout(() => toast.style.opacity = '0', 2000);
    }
    
    function shakeCanvas() {
        canvas.style.transform = 'translate(3px, 0)';
        setTimeout(() => canvas.style.transform = 'translate(-3px, 0)', 50);
        setTimeout(() => canvas.style.transform = 'none', 100);
    }

    // ÂêØÂä®Ê∏∏Êàè
    initLevel();

</script>
</body>
</html>
