<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Hunter V5 - Perfect Control</title>
    <style>
        body {
            margin: 0;
            background-color: #f0f4f8;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
        }

        #ui-layer {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            box-sizing: border-box;
            background: #ffffff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10;
            border-radius: 0 0 15px 15px;
        }

        .stat-box { text-align: center; }
        .stat-label { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { font-size: 22px; font-weight: 800; color: #444; }
        #killed { color: #e57373; }

        #game-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            max-width: 500px;
            background: #f0f4f8;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            background: #ffffff;
        }

        /* å¼ºåˆ¶è¦†ç›–å±‚çº§ï¼Œç¡®ä¿å¼¹çª—åœ¨æœ€ä¸Šå±‚ */
        #modal {
            display: none; 
            position: fixed; /* æ”¹ä¸º fixed ç¡®ä¿ä¸è·‘å */
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.95);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #333;
            text-align: center;
        }
        #modal h2 { font-size: 36px; margin-bottom: 10px; color: #2c3e50; }
        #modal p { font-size: 20px; margin-bottom: 30px; font-weight: 500; color: #555; }
        #modal button {
            padding: 15px 40px;
            font-size: 20px;
            background: #66bb6a;
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(102, 187, 106, 0.4);
            font-weight: bold;
            transition: transform 0.1s;
        }
        #modal button:active { transform: scale(0.95); }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="timer">60</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Kills</div>
            <div class="stat-value"><span id="killed">0</span> / <span id="target">15</span> ğŸ‘¾</div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="modal">
        <h2 id="modal-title">Game Over</h2>
        <p id="modal-desc">...</p>
        <button id="restartBtn">Try Again</button>
    </div>

<script>
/**
 * V5.0 é…ç½®
 */
const GRID_SIZE = 8;
const COLORS = {
    bg: '#ffffff',
    gridLine: '#f1f2f6',
    gridFilled: '#81c784', 
    gridFilledBorder: '#4caf50',
    monster: '#e57373',
    monsterText: 'ğŸ‘¾',
    // é¢„è§ˆé¢œè‰²ç¨å¾®è°ƒæ·¡ä¸€ç‚¹ï¼Œä¸è¦æŠ¢çœ¼
    ghostValid: 'rgba(129, 199, 132, 0.3)', 
    ghostInvalid: 'rgba(229, 115, 115, 0.3)'
};

// ç²’å­ç‰¹æ•ˆ
class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.size = Math.random() * 4 + 2;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life -= this.decay;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

const SHAPES = [
    [[1]], [[1, 1]], [[1], [1]], 
    [[1, 1, 1]], [[1], [1], [1]], 
    [[1, 1], [1, 1]], 
    [[1, 0], [1, 0], [1, 1]], 
    [[0, 1], [0, 1], [1, 1]], 
    [[1, 1, 1], [0, 1, 0]], 
    [[1, 1, 0], [0, 1, 1]]
];

class Block {
    constructor(shapeMatrix) {
        this.shape = shapeMatrix;
        this.rows = shapeMatrix.length;
        this.cols = shapeMatrix[0].length;
        this.x = 0; this.y = 0;
        this.originalX = 0; this.originalY = 0;
        this.isDragging = false;
        this.scale = 0.6; 
        this.placed = false;
        this.inputType = 'mouse'; // è®°å½•æ˜¯é¼ æ ‡è¿˜æ˜¯è§¦æ‘¸ï¼Œå†³å®šåç§»ç­–ç•¥
    }
}

class Monster {
    constructor(r, c) {
        this.r = r; this.c = c;
        this.moveTimer = Math.random() * 1.0; 
        this.moveInterval = 2.0; 
        this.animX = 0; this.animY = 0;
    }
    update(dt, game) {
        this.animX *= 0.8; this.animY *= 0.8;
        this.moveTimer += dt;
        if (this.moveTimer >= this.moveInterval) {
            this.moveTimer = 0;
            this.tryMove(game);
        }
    }
    tryMove(game) {
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        let validMoves = [];
        for (let d of dirs) {
            const nr = this.r + d[0];
            const nc = this.c + d[1];
            if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                if (game.grid[nr][nc] === 0 && !game.monsters.some(m => m.r === nr && m.c === nc)) {
                    validMoves.push({r: nr, c: nc});
                }
            }
        }
        if (validMoves.length > 0) {
            const move = validMoves[Math.floor(Math.random() * validMoves.length)];
            this.r = move.r; this.c = move.c;
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.timerEl = document.getElementById('timer');
        this.killedEl = document.getElementById('killed');
        this.modal = document.getElementById('modal');
        this.restartBtn = document.getElementById('restartBtn');
        
        // ç»‘å®šé‡å¯æŒ‰é’®äº‹ä»¶ï¼Œç¡®ä¿é—­åŒ…æ­£ç¡®
        this.restartBtn.onclick = () => {
            this.modal.style.display = 'none'; // ç«‹å³éšè—
            this.init();
        };

        this.particles = [];
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // äº‹ä»¶ç»‘å®š
        const bind = (type, handler) => this.canvas.addEventListener(type, handler.bind(this), {passive: false});
        bind('mousedown', this.handleStart);
        bind('mousemove', this.handleMove);
        bind('mouseup', this.handleEnd);
        bind('touchstart', this.handleStart);
        bind('touchmove', this.handleMove);
        bind('touchend', this.handleEnd);

        this.init();
    }

    resize() {
        const container = document.getElementById('game-container');
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.boardSize = Math.min(this.width, this.height * 0.65) - 20; 
        this.cellSize = (this.boardSize / GRID_SIZE);
        this.boardX = (this.width - this.boardSize) / 2;
        this.boardY = 30;

        this.dockY = this.boardY + this.boardSize + 30;
        this.dockHeight = this.height - this.dockY;
    }

    init() {
        this.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        this.monsters = [];
        this.handBlocks = [];
        this.particles = [];
        this.score = 0;
        this.killedCount = 0;
        this.targetKills = 15;
        this.timeLeft = 90; // å•å±€æ—¶é•¿æ”¹ä¸º 1.5 åˆ†é’Ÿ
        this.gameState = 'playing';
        this.lastTime = performance.now(); // é‡ç½®æ—¶é—´åŸºå‡†ï¼Œé¿å…é‡å¼€æ—¶å‡ºç°è¶…å¤§ dt
        this.monsterSpawnTimer = 0;
        this.monsterSpawnInterval = 4.5; 
        this.activeBlock = null;
        this.hoverPos = null; // è®°å½•æ‹–æ‹½æ—¶æŒ‡é’ˆä½ç½®ï¼Œç”¨äºæ›´ç²¾å‡†çš„é¢„è§ˆ

        this.killedEl.innerText = 0;
        this.timerEl.innerText = 180;
        this.modal.style.display = 'none'; // å†æ¬¡ç¡®ä¿éšè—

        this.spawnHand();
        this.spawnMonster();
        this.spawnMonster();
        
        // å¦‚æœæ²¡æœ‰æ­£åœ¨è¿è¡Œçš„å¾ªç¯ï¼Œå¯åŠ¨å®ƒ
        if (!this.running) {
            this.running = true;
            this.loop(this.lastTime); // ä¼ å…¥å½“å‰æ—¶é—´ï¼Œé¿å…é¦–å¸§ dt è¿‡å¤§
        }
    }

    spawnHand() {
        this.handBlocks = [];
        const slotWidth = this.width / 3;
        for (let i = 0; i < 3; i++) {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const b = new Block(shape);
            const blockWidth = b.cols * this.cellSize * b.scale;
            const blockHeight = b.rows * this.cellSize * b.scale;
            b.x = i * slotWidth + (slotWidth - blockWidth) / 2;
            b.y = this.dockY + (this.dockHeight - blockHeight) / 2;
            b.originalX = b.x; b.originalY = b.y;
            this.handBlocks.push(b);
        }
        this.checkGameOver();
    }

    spawnMonster() {
        let emptySpots = [];
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (this.grid[r][c] === 0 && !this.monsters.find(m => m.r === r && m.c === c)) {
                    emptySpots.push({r, c});
                }
            }
        }
        if (emptySpots.length > 0) {
            const spot = emptySpots[Math.floor(Math.random() * emptySpots.length)];
            this.monsters.push(new Monster(spot.r, spot.c));
        }
    }

    update(dt) {
        if (this.gameState !== 'playing') return;

        this.timeLeft -= dt;
        this.timerEl.innerText = Math.ceil(this.timeLeft);
        if (this.timeLeft <= 0) {
            this.endGame(false, "Time Out!");
            return;
        }

        this.monsterSpawnTimer += dt;
        if (this.monsterSpawnTimer > this.monsterSpawnInterval) {
            this.spawnMonster();
            this.monsterSpawnTimer = 0;
        }

        this.monsters.forEach(m => m.update(dt, this));

        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        if (this.handBlocks.every(b => b.placed)) this.spawnHand();
    }

    draw() {
        this.ctx.fillStyle = COLORS.bg;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // 1. ç»˜åˆ¶ç½‘æ ¼çº¿å’Œå·²æ”¾ç½®çš„æ–¹å—
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const x = this.boardX + c * this.cellSize;
                const y = this.boardY + r * this.cellSize;
                
                this.ctx.strokeStyle = COLORS.gridLine;
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x, y, this.cellSize, this.cellSize);

                if (this.grid[r][c] === 1) {
                    this.drawCell(x, y, this.cellSize, COLORS.gridFilled, COLORS.gridFilledBorder);
                }
            }
        }

        // 2. ç»˜åˆ¶æ‹–æ‹½æ—¶çš„â€œå¹½çµæ–¹å—â€ï¼ˆé¢„è§ˆï¼‰
        // å…³é”®æ”¹åŠ¨ï¼šå…ˆç”»é¢„è§ˆï¼Œå†ç”»æ€ªç‰©ã€‚è¿™æ ·æ€ªç‰©æ°¸è¿œåœ¨é¢„è§ˆä¹‹ä¸Šï¼Œä¸ä¼šå˜è‰²ã€‚
        if (this.activeBlock && this.activeBlock.isDragging) {
            const pointerPos = this.hoverPos;
            const rawPos = pointerPos ? this.getGridPosFromPointer(pointerPos, this.activeBlock) : this.getGridPosFromXY(this.activeBlock.x, this.activeBlock.y, this.activeBlock);
            const gridPos = rawPos ? this.clampGridPos(rawPos, this.activeBlock) : null;
            if (gridPos) {
                const valid = this.canPlace(this.activeBlock.shape, gridPos.r, gridPos.c);
                const ghostColor = valid ? COLORS.ghostValid : COLORS.ghostInvalid;
                this.drawGhost(this.activeBlock.shape, gridPos.r, gridPos.c, ghostColor);
            }
        }

        // 3. ç»˜åˆ¶æ€ªç‰© (ç¡®ä¿å±‚çº§é«˜ï¼Œé¢œè‰²é²œè‰³)
        this.ctx.font = `${this.cellSize * 0.7}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        for (let m of this.monsters) {
            const cx = this.boardX + m.c * this.cellSize + this.cellSize/2 + m.animX;
            const cy = this.boardY + m.r * this.cellSize + this.cellSize/2 + m.animY;
            const s = 1 + Math.sin(Date.now() / 200) * 0.1;
            this.ctx.save();
            this.ctx.translate(cx, cy);
            this.ctx.scale(s, s);
            // å…ˆç”¨çº¯è‰²ç€è‰²ï¼Œå†ç”¨ emoji ç»˜åˆ¶
            this.ctx.fillStyle = COLORS.monster;
            this.ctx.fillText(COLORS.monsterText, 0, 0);
            this.ctx.restore();
        }

        // 4. ç»˜åˆ¶ç²’å­
        for (let p of this.particles) p.draw(this.ctx);

        // 5. ç»˜åˆ¶æ‰‹ç‰Œ (æ‹–æ‹½çš„æ–¹å—åœ¨æœ€æœ€ä¸Šå±‚)
        for (let b of this.handBlocks) {
            if (!b.placed) this.drawBlock(b);
        }
    }

    drawCell(x, y, sideLength, color, borderColor) {
        const pad = 2;
        const size = sideLength - pad * 2;
        const dx = x + pad;
        const dy = y + pad;

        this.ctx.fillStyle = color;
        this.ctx.fillRect(dx, dy, size, size);
        
        if (borderColor) {
            this.ctx.strokeStyle = borderColor;
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(dx, dy, size, size);
        }
        
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.fillRect(dx, dy, size, size/3);
    }

    drawBlock(block) {
        const scale = block.isDragging ? 1 : block.scale;
        const currentCellSize = this.cellSize * scale;

        // æ‹–æ‹½æ—¶ç¨å¾®é€æ˜ä¸€ç‚¹ï¼Œä»¥ä¾¿çœ‹æ¸…ä¸‹æ–¹ï¼ˆä½†è¿™ä¸ä¼šå½±å“å·²ç»ç”»å¥½çš„æ€ªç‰©ï¼‰
        this.ctx.globalAlpha = block.isDragging ? 0.9 : 1.0;
        
        for (let r = 0; r < block.rows; r++) {
            for (let c = 0; c < block.cols; c++) {
                if (block.shape[r][c]) {
                    let dx = block.x + c * currentCellSize;
                    let dy = block.y + r * currentCellSize;
                    
                    if (!block.isDragging) {
                       this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                       this.ctx.fillRect(dx + 3, dy + 3, currentCellSize - 4, currentCellSize - 4);
                    }
                    this.drawCell(dx, dy, currentCellSize, COLORS.gridFilled, COLORS.gridFilledBorder);
                }
            }
        }
        this.ctx.globalAlpha = 1.0;
    }

    drawGhost(shape, r, c, color) {
        this.ctx.fillStyle = color;
        for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[0].length; j++) {
                if (shape[i][j]) {
                    const x = this.boardX + (c + j) * this.cellSize;
                    const y = this.boardY + (r + i) * this.cellSize;
                    this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
                }
            }
        }
    }

    loop(timestamp) {
        if (!this.running) return;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(this.loop.bind(this));
    }

    getTouchPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    // åŸºäºæŒ‡é’ˆä½ç½® + æ–¹å—å°ºå¯¸è®¡ç®—å·¦ä¸Šè§’æ ¼å­ï¼Œè®©åˆ¤å®šä¸æ–¹å—ä¸­å¿ƒå¯¹é½
    getGridPosFromPointer(pos, block) {
        const c = Math.floor((pos.x - this.boardX) / this.cellSize - block.cols / 2);
        const r = Math.floor((pos.y - this.boardY) / this.cellSize - block.rows / 2);
        return { r, c };
    }

    // å°†æ ¼å­åæ ‡é™åˆ¶åœ¨æ£‹ç›˜èŒƒå›´ï¼Œè‹¥è¶…ç•Œè¿”å› null
    clampGridPos(pos, block) {
        const maxR = GRID_SIZE - block.rows;
        const maxC = GRID_SIZE - block.cols;
        if (pos.r < 0 || pos.c < 0 || pos.r > maxR || pos.c > maxC) return null;
        return pos;
    }

    handleStart(e) {
        if (this.gameState !== 'playing') return;
        e.preventDefault();
        const pos = this.getTouchPos(e);
        this.hoverPos = pos;
        const isTouch = e.type === 'touchstart';

        for (let b of this.handBlocks) {
            if (b.placed) continue;
            const w = b.cols * this.cellSize * b.scale;
            const h = b.rows * this.cellSize * b.scale;
            
            // æ‰©å¤§ç‚¹å‡»åˆ¤å®šèŒƒå›´
            if (pos.x >= b.x - 20 && pos.x <= b.x + w + 20 && pos.y >= b.y - 20 && pos.y <= b.y + h + 20) {
                this.activeBlock = b;
                b.isDragging = true;
                b.inputType = isTouch ? 'touch' : 'mouse';

                // æ ¸å¿ƒä¿®å¤ï¼šæ‰‹æ„Ÿä¼˜åŒ–
                // 1. é¼ æ ‡æ¨¡å¼ï¼šæ–¹å—ä¸­å¿ƒå¯¹å‡†é¼ æ ‡
                // 2. è§¦æ‘¸æ¨¡å¼ï¼šæ–¹å—ä¸Šç§» 1.2 å€æ ¼ï¼Œé˜²æ­¢æ‰‹æŒ‡é®æŒ¡
                
                const targetW = b.cols * this.cellSize; // å˜å¤§åçš„å®½åº¦
                const targetH = b.rows * this.cellSize; // å˜å¤§åçš„é«˜åº¦
                
                // è®¡ç®—è®©æ–¹å—ä¸­å¿ƒå¯¹å‡†æ‰‹æŒ‡çš„åæ ‡
                let centeredX = pos.x - targetW / 2;
                let centeredY = pos.y - targetH / 2;

                if (b.inputType === 'touch') {
                    // å¦‚æœæ˜¯è§¦æ‘¸ï¼Œé¢å¤–å‘ä¸Šåç§»
                    centeredY -= this.cellSize * 1.2;
                }

                b.x = centeredX;
                b.y = centeredY;
                break;
            }
        }
    }

    handleMove(e) {
        if (!this.activeBlock) return;
        e.preventDefault();
        const pos = this.getTouchPos(e);
        this.hoverPos = pos;
        
        const targetW = this.activeBlock.cols * this.cellSize;
        const targetH = this.activeBlock.rows * this.cellSize;

        let centeredX = pos.x - targetW / 2;
        let centeredY = pos.y - targetH / 2;

        if (this.activeBlock.inputType === 'touch') {
             centeredY -= this.cellSize * 1.2;
        }

        this.activeBlock.x = centeredX;
        this.activeBlock.y = centeredY;
    }

    handleEnd(e) {
        if (!this.activeBlock) return;
        e.preventDefault();
        const targetPos = this.hoverPos || this.getTouchPos(e);
        const rawPos = this.getGridPosFromPointer(targetPos, this.activeBlock);
        const gridPos = rawPos ? this.clampGridPos(rawPos, this.activeBlock) : null;
        
        if (gridPos && this.canPlace(this.activeBlock.shape, gridPos.r, gridPos.c)) {
            this.placeBlock(this.activeBlock.shape, gridPos.r, gridPos.c);
            this.activeBlock.placed = true;
            this.activeBlock.isDragging = false;
            this.activeBlock = null;
            this.checkLines();
            setTimeout(() => this.checkGameOver(), 100); 
        } else {
            this.activeBlock.isDragging = false;
            this.activeBlock.x = this.activeBlock.originalX;
            this.activeBlock.y = this.activeBlock.originalY;
            this.activeBlock = null;
        }
    }

    getGridPosFromXY(x, y, block) {
        const centerX = x + (block.cols * this.cellSize) / 2;
        const centerY = y + (block.rows * this.cellSize) / 2;
        const c = Math.floor((centerX - this.boardX) / this.cellSize);
        const r = Math.floor((centerY - this.boardY) / this.cellSize);
        return { r, c };
    }

    canPlace(shape, r, c) {
        for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[0].length; j++) {
                if (shape[i][j]) {
                    const newR = r + i;
                    const newC = c + j;
                    if (newR < 0 || newR >= GRID_SIZE || newC < 0 || newC >= GRID_SIZE) return false;
                    if (this.grid[newR][newC] === 1) return false;
                    if (this.monsters.some(m => m.r === newR && m.c === newC)) return false;
                }
            }
        }
        return true;
    }

    placeBlock(shape, r, c) {
        for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[0].length; j++) {
                if (shape[i][j]) this.grid[r + i][c + j] = 1;
            }
        }
    }

    spawnCellClearEffect(r, c) {
        const cx = this.boardX + c * this.cellSize + this.cellSize / 2;
        const cy = this.boardY + r * this.cellSize + this.cellSize / 2;
        // ç”¨æ›´å°é¢—ç²’çš„ç»¿è‰²çˆ†ç‚¸ï¼Œå¼ºè°ƒæ¸…é™¤
        for (let i = 0; i < 8; i++) this.particles.push(new Particle(cx, cy, COLORS.gridFilledBorder));
    }

    checkLines() {
        let rows = [], cols = [];
        for (let r = 0; r < GRID_SIZE; r++) {
            if (this.grid[r].every(v => v === 1)) rows.push(r);
        }
        for (let c = 0; c < GRID_SIZE; c++) {
            let full = true;
            for (let r = 0; r < GRID_SIZE; r++) if (this.grid[r][c] === 0) full = false;
            if (full) cols.push(c);
        }
        if (rows.length > 0 || cols.length > 0) this.clearLines(rows, cols);
    }

    spawnExplosion(x, y, color) {
        for(let i=0; i<15; i++) this.particles.push(new Particle(x, y, color));
    }

    clearLines(rows, cols) {
        // å…ˆä¸ºè¢«æ¸…é™¤çš„æ ¼å­æ‰“ä¸Šç‰¹æ•ˆ
        const cleared = new Set();
        rows.forEach(r => {
            for (let c = 0; c < GRID_SIZE; c++) {
                const key = `${r},${c}`;
                cleared.add(key);
            }
        });
        cols.forEach(c => {
            for (let r = 0; r < GRID_SIZE; r++) {
                const key = `${r},${c}`;
                cleared.add(key);
            }
        });
        cleared.forEach(key => {
            const [r, c] = key.split(',').map(Number);
            this.spawnCellClearEffect(r, c);
        });

        rows.forEach(r => { for(let c=0; c<GRID_SIZE; c++) this.grid[r][c] = 0; });
        cols.forEach(c => { for(let r=0; r<GRID_SIZE; r++) this.grid[r][c] = 0; });

        let kills = 0;
        this.monsters = this.monsters.filter(m => {
            let dead = false;
            for (let r of rows) if (Math.abs(m.r - r) <= 1) dead = true;
            for (let c of cols) if (Math.abs(m.c - c) <= 1) dead = true;
            
            if (dead) {
                kills++;
                const cx = this.boardX + m.c * this.cellSize + this.cellSize/2;
                const cy = this.boardY + m.r * this.cellSize + this.cellSize/2;
                this.spawnExplosion(cx, cy, COLORS.monster);
            }
            return !dead;
        });

        if (kills > 0) {
            this.killedCount += kills;
            this.killedEl.innerText = this.killedCount;
            if (this.killedCount >= this.targetKills) this.endGame(true, "Mission Complete!");
        }
    }

    checkGameOver() {
        let availableBlocks = this.handBlocks.filter(b => !b.placed);
        if (availableBlocks.length === 0) return;

        let canMove = false;
        for (let b of availableBlocks) {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (this.canPlace(b.shape, r, c)) {
                        canMove = true;
                        break;
                    }
                }
                if (canMove) break;
            }
            if (canMove) break;
        }
        if (!canMove) this.endGame(false, "No Moves Left!");
    }

    endGame(win, reason) {
        this.gameState = win ? 'win' : 'gameover';
        this.modal.style.display = 'flex';
        document.getElementById('modal-title').innerText = win ? 'Victory!' : 'Defeat';
        document.getElementById('modal-desc').innerText = reason + `\nScore: ${this.killedCount}`;
    }
}

window.game = new Game();
</script>
</body>
</html>
